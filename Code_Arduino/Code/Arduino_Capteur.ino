//================  Code arduino pour le projet capteur de déformation low-tech à base de graphite, 4ème année Génie Physique à l'INSA Toulouse ======================//
//Raoul Dabadie et Mattéo Labrousse

#include <SPI.h>    //Librairie liée à la liaison SPI pour le potentiomètre digital
#include <Adafruit_SSD1306.h> //Librairie liée à l'écran OLED
#include <math.h>   //Librairie de fonctions mathématiques

//============== PARAMETRES ===============//

//Potentiomètre digital
const byte csPin = 10 ;   //MCP42100 chip select pin
const int maxPositions = 256 ; //Wiper (sliding contact) pouvant aller de 0 à 256
const long rAB = 50000; // 50k pot resistance entre les terminaux A et B 

const byte rWiper = 125;  // 125 ohms pot wiper position 
const byte pot0 = 0x11 ;    //adresse pot0
const byte pot0Shutdown = 0x21;   //arrêt pot0 

int pos_calibre = 0; //Permet de trouver la résistance adéquate
float sensorValue;  //Valeur de tension récupérée

//Encodeur Rotatoir
#define encoder0PinA 3  //Pin de la clock de l'encodeur rotatoir
#define encoder0PinB 4  //Pin des datas de l'encodeur rotatoir
#define Switch 2  //Pin permettant l'acquisition de l'enclenchement de l'encodeur
volatile int encoder0Pos = 0;   //Position de l'encodeur lors de sa rotation

long PreviousMillis = 0 ; //associé au CLK
long LastMillis = 0 ; //associé au CLK
long PreviousMillis2 = 0 ; //associé au Switch
long LastMillis2 = 0 ; //associé au Switch

volatile bool clic = false;   //Booléen permettant de naviguer dans le menu OLED

//==========================
//Composants du circuit

long R1 = 100000 ;
long R3 = 100000 ;
int R5 = 10000 ;
int VCC = 5 ; //VCC égal à 5V
long Rcal;  //Rcalibration du potentiomètre digital

//==========================
//BLUETOOTH

#include <SoftwareSerial.h>
#define rxPin 6   //Pin de réception des données bluetooth
#define txPin 5   //Pin d'envoi des données bluetooth
byte serialRX;  //Variable recevant les valeurs 

SoftwareSerial mySerial(rxPin,txPin); //Permet la communication bluetooth

//==========================

//ECRAN OLED

#define nombreDePixelsEnLargeur 128   // Taille de l'écran OLED, en pixel, au niveau de sa largeur
#define nombreDePixelsEnHauteur 64    // Taille de l'écran OLED, en pixel, au niveau de sa hauteur
#define brocheResetOLED -1    // Reset de l'OLED partagé avec l'Arduino (d'où la valeur à -1, et non un numéro de pin)
#define adresseI2CecranOLED 0x3C    // Adresse de l'écran OLED sur le bus i2c 
Adafruit_SSD1306 ecranOLED(nombreDePixelsEnLargeur, nombreDePixelsEnHauteur, &Wire, brocheResetOLED);

#define largeurDeLimage           128          // Largeur de l'image à afficher, en pixels
#define hauteurDeLimage           64          // Hauteur de l'image à afficher, en pixels

//image à afficher par l'écran

const unsigned char DabLab [] PROGMEM = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xf8, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xf0, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xe0, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0x07, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xf8, 0x01, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xfe, 0x01, 0xff, 0xe0, 0x1f, 0xff, 0xff, 0xff, 0xf0, 0x00, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xfe, 0x04, 0x1f, 0xf0, 0x0f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x7f, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xfe, 0x08, 0x07, 0xfc, 0x1f, 0xff, 0xff, 0xff, 0xc7, 0xff, 0x3f, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x0b, 0x83, 0x80, 0x1f, 0xff, 0xff, 0xff, 0x8f, 0xff, 0x9f, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xfe, 0x0c, 0x03, 0x00, 0x1f, 0xff, 0xff, 0xff, 0x1f, 0xff, 0xcf, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xfe, 0x1e, 0x07, 0x00, 0x3f, 0xff, 0xff, 0xff, 0x1f, 0xff, 0xcf, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xfe, 0x1f, 0xbf, 0x00, 0x7f, 0xff, 0xff, 0xff, 0x1f, 0xff, 0xc7, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xfe, 0x1f, 0xff, 0x00, 0x7f, 0xff, 0xff, 0xfe, 0x1f, 0xff, 0xc7, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x9f, 0xff, 0xe0, 0x7f, 0xff, 0xff, 0xfe, 0x1f, 0xff, 0xc3, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xdf, 0xff, 0xfc, 0x7f, 0xff, 0xff, 0xfe, 0x09, 0xf8, 0x03, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xdf, 0xff, 0xfc, 0x7f, 0xff, 0xff, 0xfe, 0x00, 0x70, 0x03, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xbf, 0xe0, 0xfc, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x70, 0x03, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xbe, 0x00, 0xfc, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x70, 0x03, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x3e, 0x38, 0x79, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x70, 0x03, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xbe, 0x00, 0x11, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x70, 0x73, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xfc, 0x01, 0xff, 0xff, 0xff, 0xfe, 0x3f, 0x7f, 0xf3, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xfe, 0xc3, 0xff, 0xff, 0xff, 0xfe, 0x3f, 0x7f, 0xf3, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xff, 0xff, 0xff, 0xfe, 0x3f, 0x37, 0xf3, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x87, 0xff, 0x87, 0xff, 0xff, 0xff, 0xfe, 0x1f, 0x07, 0xc7, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x83, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x07, 0xc7, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x80, 0x3f, 0x0f, 0xff, 0xff, 0xff, 0xfe, 0x0f, 0x07, 0xe7, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x80, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0x0c, 0x71, 0xcf, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x80, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0x88, 0x01, 0xcf, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x80, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0x86, 0xf7, 0x0f, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x80, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xc6, 0x06, 0x1f, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xe0, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x9e, 0x1f, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x70, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xc3, 0xfe, 0x1f, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xf8, 0xf0, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xe1, 0xfc, 0x0f, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xfe, 0xf8, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x0f, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xfe, 0xf8, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x0f, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xf8, 0x00, 0x23, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x0f, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xf8, 0x01, 0x20, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x07, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xf8, 0x00, 0x60, 0x3f, 0xff, 0xff, 0xff, 0x00, 0x00, 0x83, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xf8, 0x00, 0xc0, 0x1f, 0xff, 0xff, 0xff, 0x00, 0x01, 0x80, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xf8, 0x01, 0x80, 0x07, 0xff, 0xff, 0xff, 0x00, 0x01, 0x80, 0x7f, 0xff, 0xff, 
  0xff, 0xff, 0xf9, 0xfc, 0x01, 0x80, 0x01, 0xff, 0xff, 0xfc, 0x00, 0x03, 0x00, 0x3f, 0xff, 0xff, 
  0xff, 0xff, 0xf8, 0xfc, 0x26, 0x00, 0x00, 0xff, 0xff, 0xf0, 0x00, 0x02, 0x00, 0x3f, 0xff, 0xff, 
  0xff, 0xff, 0xf8, 0x3f, 0xfc, 0x00, 0x00, 0x3f, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 
  0xff, 0xff, 0xf8, 0x0f, 0xe0, 0x00, 0x00, 0x1f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 
  0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 
  0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xfc, 0x00, 0x00, 0x07, 0xbf, 0xff, 0xff, 
  0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xfc, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xfc, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xfe, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xfe, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff
};

//========================== FONCTIONS==========================//

//POTENTIOMETRE DIGITAL
//Utilisation du potentiomètre digital afin de choisir une résistance
void setPotWiper(int addr, int pos_calibre) { 
  pos_calibre = constrain (pos_calibre, 0, 255);  
  digitalWrite(csPin, LOW);
  SPI.transfer(addr);
  SPI.transfer(pos_calibre);
  digitalWrite(csPin, HIGH);

  Rcal = ((rAB * pos_calibre) / maxPositions) + rWiper ; //Résistance réglée par le potentiomètre
}

//==========================
//Encodeur rotatoir
//Fait évoluer la variable encoder0Pos lors de la rotation de l'encodeur. Utile pour se déplacer dans le menu de l'OLED
void doEncoder() {
  LastMillis = millis() ; 
  if (abs(LastMillis - PreviousMillis) >= 150){
  if (digitalRead(encoder0PinB)==HIGH) {
    encoder0Pos++;
    }
    else {
      encoder0Pos--;
   }
   PreviousMillis = millis() ; 
  }
}

//Permet de changer la valeur du booléen "clic" lors de l'enclenchement du bouton de l'encodeur rotatoir. Utile pour le menu de l'OLED
void DoSwitch(){
  LastMillis2 = millis() ; 
  if (abs(LastMillis2 - PreviousMillis2) >= 50){
    clic = !clic ;
  }
  PreviousMillis2 = millis() ; 
}
//==========================
//Affichage de la résistance sur l'écran OLED
void Aff_Resistance(){
  ecranOLED.clearDisplay();
  float sensorValue = analogRead(0);
  float Vadc = sensorValue*5/1023;
  float Rsensor = (1+R3/Rcal)*R1*VCC/Vadc-R1-R5;
  float Rsensor_kohm = Rsensor*pow(10,-3);
  ecranOLED.setCursor(0, 0);
  ecranOLED.setTextColor(SSD1306_INVERSE);
  ecranOLED.setTextSize(2);
  ecranOLED.println("R sensor :");
  ecranOLED.println("");
  ecranOLED.println(Rsensor_kohm);
  ecranOLED.print("     kohms");
  ecranOLED.display();
}

void Aff_Tension(){
  ecranOLED.clearDisplay();
  ecranOLED.setTextColor(SSD1306_INVERSE);
  ecranOLED.setTextSize(2);
  ecranOLED.setCursor(0, 0);
  ecranOLED.println("   Vadc ");
  float sensorValue = analogRead(0);
  float Vadc = sensorValue*5/1023;
  ecranOLED.println("");
  ecranOLED.setTextSize(3);
  ecranOLED.print(Vadc);
  ecranOLED.print(" V");
  ecranOLED.display();
}

//==========================
// La fonction setup est rappelée lorsque l'on presse reset

void setup() {
  // initialisation de la communication série à 9600 bits par seconde :
  Serial.begin(9600);

  //Initialisation du potentiomètre digital
  digitalWrite(csPin, HIGH);
  pinMode(csPin, OUTPUT);
  SPI.begin();
  setPotWiper(pot0, pos_calibre); //La résistance Rcal est minimale

  ///////////// Bluetooth ///////////////////
  pinMode(rxPin, INPUT);
  pinMode(txPin, OUTPUT);
  mySerial.begin(9600); //ouvre la voie série avec le module bluetooth

  ///////////// Encoder /////////////////////
  pinMode(encoder0PinA, INPUT);
  digitalWrite(encoder0PinA, HIGH);
  pinMode(encoder0PinB, INPUT);
  digitalWrite(encoder0PinB, HIGH);
  pinMode(Switch, INPUT);
  digitalWrite(Switch, HIGH);

  attachInterrupt(digitalPinToInterrupt(encoder0PinA), doEncoder, CHANGE);  //Lorsque l'état de la clock change, la fonction doEncoder est appelée
  attachInterrupt(digitalPinToInterrupt(Switch), DoSwitch, RISING);   //Lorsque le pin switch est dans l'état haut (bouton de l'encodeur enclenché), la fonction DoSwitch est appelée

  //////////// Ecran OLED /////////////////
  if(!ecranOLED.begin(SSD1306_SWITCHCAPVCC, adresseI2CecranOLED)) //Démarrage de l'écran OLED
  while(1);

  // Calibrage de la résistance Rcal du potentiomètre digital afin de choisir une tension de sortie ADC d'environ 2,5V, afin de ne pas saturer à 5V
  do{
    setPotWiper(pot0, pos_calibre); 
    delay(1000);
    sensorValue = (analogRead(0)*5/1023); //Valeur de la tension de sortie ADC, correspondant à la valeur en bits de la pin convertie sur 5V
    pos_calibre++;
    Serial.println(pos_calibre);
    Serial.print(Rcal);
    Serial.println(" ohms");
  }  while (sensorValue > 2.5);  // Tant que la valeur de sortie n'atteint pas les 2.5V, Rcal augmente toutes les secondes

  Serial.print("Rcal finale : ");
  Serial.print(Rcal);   //On affiche la valeur finale de Rcal dans le port série
  Serial.println( " ohms");
  Serial.println( " ");
  
}

//==========================

// Boucle tournant en continu
void loop() {

    while (mySerial.available()) {
      serialRX = mySerial.read(); //lecture du bit envoyé par l'application: 2 cas possibles
      if (serialRX==1){ //serialRX=1 permet d'envoyer la valeur de Rcal pour calibrer les mesures
          mySerial.print(Rcal/4);
      }
      else {   //sinon permet d'envoyer les valeurs de tension
          float sensorValue = analogRead(0);  // Lit la valeur analogique d'entrée du pin A0
          mySerial.write(sensorValue/4);  //On envoie la tension codée sur 8 bits à l'application bluetooth (1024/4 = 256)
      }}
    
    float sensorValue = analogRead(0);  // Lit la valeur analogique d'entrée du pin A0
    float Vadc = sensorValue*5/1023;  //Cette valeur est convertie en volt
    //mySerial.write(sensorValue/4);  //On envoie la tension codée sur 8 bits à l'application bluetooth (1024/4 = 256)
    
    float Rsensor = (1+R3/Rcal)*R1*VCC/Vadc-R1-R5;  //Formule permettant de retrouver la valeur de résistance du capteur à travers le circuit transimpédance
    float Rsensor_Mohm = Rsensor*pow(10,-6);    //On convertit cette valeur en mégaohms


    Serial.print("Rsensor : ");
    Serial.print(Rsensor_Mohm); //On écrit la valeur de résistance en Mohms sur le port série 
    Serial.println(" Mohms");

    delay(100);        // delai dans la boucle pour garder de la stabilité

   
    //==========================
    //MENU ECRAN OLED
      
    ecranOLED.clearDisplay();
    ecranOLED.setTextSize(2.5);
  
    ///LIGNE1 du menu OLED///
    ecranOLED.setCursor(0, 0);

    //On navigue dans le menu à l'aide de l'encodeur rotatoire. Le modulo permet de se déplacer en continu dans le menu
    if ((abs(encoder0Pos) % 9) < 3){  
      ecranOLED.setTextColor(SSD1306_BLACK, SSD1306_WHITE); //Le "curseur" pour se déplacer dans le menu correspond à un changement de couleur de la ligne

      //Lorsque le bouton de l'encodeur est enclenché et que l'on est sur la première ligne du menu, on affiche la résistance
      while (clic){
        Aff_Resistance();
        delay(200);
      }
    }
    else {ecranOLED.setTextColor(SSD1306_INVERSE);}
    ecranOLED.println("Resistance");  //Nom de la première ligne du menu
  
    ///LIGNE2/// 
    if (((abs(encoder0Pos) % 9) < 3)||((abs(encoder0Pos) % 9) >5)){  
      ecranOLED.setTextColor(SSD1306_INVERSE);
    }
    else {
      ecranOLED.setTextColor(SSD1306_BLACK, SSD1306_WHITE);

      //Lorsque le bouton de l'encodeur est enclenché et que l'on est sur la deuxième ligne du menu, on affiche la tension
      while (clic) {
          Aff_Tension();
          delay(500);
      }
    }
    ecranOLED.println("Voltage"); //Nom de la deuxième ligne du menu
  
    ///LIGNE3///
    if ((abs(encoder0Pos) % 9) >5){  
      ecranOLED.setTextColor(SSD1306_BLACK, SSD1306_WHITE);

      //Lorsque le bouton de l'encodeur est enclenché et que l'on est sur la troisième ligne du menu, on affiche une image
      while (clic){
        ecranOLED.clearDisplay(); 
        ecranOLED.drawBitmap(
            (ecranOLED.width()  - largeurDeLimage ) / 2,      // Position de l'extrême "gauche" de l'image (pour centrage écran, ici)
            (ecranOLED.height() - hauteurDeLimage) / 2,       // Position de l'extrême "haute" de l'image (pour centrage écran, ici)
            DabLab, //Nom de l'image affichée
            largeurDeLimage,
            hauteurDeLimage,
            WHITE); 
        ecranOLED.setTextColor(SSD1306_INVERSE);
        ecranOLED.setTextSize(1);
        ecranOLED.setCursor(0, 0);
        ecranOLED.println("        DabLab ");
        ecranOLED.display();
      }}
      
    else { ecranOLED.setTextColor(SSD1306_INVERSE); }
    
    ecranOLED.print("Creators");  //Nom de la troisième ligne du menu
    ecranOLED.display();    
}
